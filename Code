package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.util.ElapsedTime;

@TeleOp(name = "Artemis.code (Blocks to Java)")
public class Artemis.code extends LinearOpMode {

  private DcMotor launcher;
  private DcMotor left_drive;
  private DcMotor right_drive;
  private CRServo left_feeder;
  private CRServo right_feeder;

  String IDLE;
  String SPIN_UP;
  String LAUNCH;
  String launchState;
  int LAUNCHER_TARGET_VELOCITY;
  String LAUNCHING;
  int LAUNCHER_MIN_VELOCITY;
  ElapsedTime launchTime;

// Inital Motors
  private void initMotors() {
    launcher.setDirection(DcMotor.Direction.REVERSE);
    left_drive.setDirection(DcMotor.Direction.REVERSE);
    launcher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    left_drive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    right_drive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    launcher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
    left_feeder.setDirection(CRServo.Direction.FORWARD);
    left_feeder.setPower(0);
    right_feeder.setPower(0);
  }

 // Variables for launch
  private void createVariables() {
    IDLE = "IDLE";
    SPIN_UP = "SPIN_UP";
    LAUNCH = "LAUNCH";
    LAUNCHING = "LAUNCHING";
    launchState = IDLE;
    LAUNCHER_TARGET_VELOCITY = 1125;
    LAUNCHER_MIN_VELOCITY = 775;
    launchTime = new ElapsedTime();
  }


  @Override
  public void runOpMode() {
    launcher = hardwareMap.get(DcMotor.class, "launcher");
    left_drive = hardwareMap.get(DcMotor.class, "left_drive");
    right_drive = hardwareMap.get(DcMotor.class, "right_drive");
    left_feeder = hardwareMap.get(CRServo.class, "left_feeder");
    right_feeder = hardwareMap.get(CRServo.class, "right_feeder");

    // Initialization blocks here.
    right_feeder.setDirection(CRServo.Direction.REVERSE);
    createVariables();
    initMotors();
    waitForStart();
    if (opModeIsActive()) {
      // Run blocks here.
      while (opModeIsActive()) {
        // Loop blocks here.
        arcadeDrive(-gamepad1.left_stick_y, gamepad1.right_stick_x);
        if (gamepad1.circle) {
          left_feeder.setPower(1);
          right_feeder.setPower(1);
        } else {
          left_feeder.setPower(0);
          right_feeder.setPower(0);
        }
        launch(gamepad1.triangle);
        telemetry.addData("Launch State", launchState);
        telemetry.addData("Launcher Motor Velocity", ((DcMotorEx) launcher).getVelocity());
        telemetry.addData("Launch Time", launchTime);
        telemetry.update();
        if (gamepad1.square) {
          ((DcMotorEx) launcher).setVelocityPIDFCoefficients(0, 0, 0, 0);
        }
        if (gamepad1.triangle) {
          ((DcMotorEx) launcher).setVelocityPIDFCoefficients(18.9, 0, 0, 0);
        }
      }
    }
  }


  private void arcadeDrive(float forward, float rotate) {
    left_drive.setPower(forward + rotate);
    right_drive.setPower(forward - rotate);
  }

    //Launcher
  private void launch(boolean shotRequested) {
    if (launchState.equals(IDLE)) {
      if (shotRequested == true) {
        launchState = SPIN_UP;
      }
    } else if (launchState.equals(SPIN_UP)) {
      ((DcMotorEx) launcher).setVelocity(LAUNCHER_TARGET_VELOCITY);
      if (((DcMotorEx) launcher).getVelocity() > LAUNCHER_MIN_VELOCITY) {
        launchState = LAUNCH;
      }
    } else if (launchState.equals(LAUNCH)) {
      left_feeder.setPower(0);
      right_feeder.setPower(0);
      launchTime.reset();
      launchState = LAUNCHING;
    } else if (launchState.equals(LAUNCHING)) {
      if (launchTime.seconds() > 0.2) {
        left_feeder.setPower(0);
        right_feeder.setPower(0);
        launchState = IDLE;
      }
    }
  }
}
